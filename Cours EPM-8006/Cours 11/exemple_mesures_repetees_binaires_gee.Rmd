---
title: "modèle logistique marginal estimé par GEE pour statut respiratoire"
output:
  html_document:
    df_print: paged
---

# Lecture des données
```{r}
resp = read.csv("respiratoire.csv")
```

# GEE avec centre

On définit les niveaux des facteurs
```{r}
resp$treatment = factor(resp$treatment,levels = c("P","A"))
resp$visit=factor(resp$visit,levels = c(4,1,2,3))
```

Modèle logistique
```{r}
library(geepack)
respGEE = geeglm(dichot~visit*treatment+sex+age+baseline+center,id=id, corstr = "ar1",data=resp,family=binomial,scale.fix=T)
summary(respGEE)
```
Attention! La fonction *anova* effectue des tests d'analyse de variance de type 1. Seul le test du terme d'interaction correspond à un test de type 3, ajusté pour les autres termes du modèle.
```{r}
anova(respGEE)
```
Pour obtenir des tests de type 3, il faut plutôt utiliser la fonction *joint_tests*.
```{r}
library(emmeans)
joint_tests(respGEE)
```

On peut aussi programmer les tests des combinaisons linéaire correspondant aux effets de type 3. Par exemple, pour le test de l'effet du traitement et estimation de cet effet (2e étape de l'approche séquentielle), on peut faire:
```{r}
library(doBy);
tr = esticon(respGEE, L = c(0,0,0,0,1,0,0,0,0,0.25,0.25,0.25))
tr
exp(tr[1,1])
```

```{r}
rPearson = resid(respGEE,type="pearson")
plot(resp$age, rPearson,ylab="Résidus de Pearson")
abline(h=0)
lines(lowess(resp$age,rPearson))
```
```{r}
rPearson = resid(respGEE,type="pearson")
plot(resp$baseline, rPearson,ylab="Résidus de Pearson")
abline(h=0)
lines(lowess(resp$baseline,rPearson))
```
## Données influentes

Voici la fonction proposée par ChatGPT où j'ai corrigé une erreur et qui devrait fonctionner mais produit un message d'erreur d'objet non-trouvé.
```{r}
# Fonction pour calculer les dfbetas
dfbetas_geeglm <- function(model, data,corstr) {
  # Coefficients du modèle complet
  beta_full <- coef(model)
  se_full   <- sqrt(diag(vcov(model)))
  
  n <- nrow(data)
  p <- length(beta_full)
  
  dfbeta_mat <- matrix(NA, nrow = n, ncol = p)
  colnames(dfbeta_mat) <- names(beta_full)
  
  # extraction des objets nécessaires
  formula <- model$call$formula
  family <- eval(model$call$family, environment(formula))
  id_name <- as.character(model$call$id)

  ids <- data[[id_name]]
  
  for (i in 1:n) {
    # retirer l'observation i
    reduced_data <- data[-i, ]
    
    # refit du modèle
    mod_i <- geeglm(
      formula = formula,
      family = family,
      id = as.factor(reduced_data[[id_name]]),
      data = reduced_data,
      corstr = corstr,
      scale.fix=T
    )
    
    beta_i <- coef(mod_i)
    
    # calcul dfbeta pour chaque coefficient
    dfbeta_mat[i, ] <- (beta_full - beta_i) / se_full
  }
  
  dfbeta_mat
}
```

Appel de la fonction qui échoue.
```{r}
# Calcul des dfbetas
# dfb <- dfbetas_geeglm(respGEE, resp,corstr="ar1")
```
L'exécution des instructions de la fonction fonctionne.
```{r}
  # Attribution des arguments
  model = respGEE
  data = resp
  corstr="ar1"
  
  beta_full <- coef(model)
  se_full   <- sqrt(diag(vcov(model)))
  
  n <- nrow(data)
  p <- length(beta_full)
  
  dfbeta_mat <- matrix(NA, nrow = n, ncol = p)
  colnames(dfbeta_mat) <- names(beta_full)
  
  # extraction des objets nécessaires
  formula <- model$call$formula
  family <- eval(model$call$family, environment(formula))
  id_name <- as.character(model$call$id)

  ids <- data[[id_name]]
  
  for (i in 1:n) {
    # retirer l'observation i
    reduced_data <- data[-i, ]
    
    # refit du modèle
    mod_i <- geeglm(
      formula = formula,
      family = family,
      id = as.factor(reduced_data[[id_name]]),
      data = reduced_data,
      corstr = corstr,
      scale.fix=T
    )
    
    beta_i <- coef(mod_i)
    
    # calcul dfbeta pour chaque coefficient
    dfbeta_mat[i, ] <- (beta_full - beta_i) / se_full
  }
  
```

Exemple d'affichage des dfbetas pour la variable traitement.
```{r}
dfb = dfbeta_mat
plot(1:nrow(dfb),dfb[,"treatmentA"])
```


Modèle log-binomial.
```{r}
library(geepack)
respGEE.log = geeglm(dichot~factor(visit)*treatment+sex+age+baseline+center,id=id, corstr = "ar1",data=resp,family=poisson(link=log),scale.fix=T)
summary(respGEE.log)
```
