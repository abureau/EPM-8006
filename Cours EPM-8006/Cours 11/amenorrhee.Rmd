---
title: "Traitement des pertes au suivi"
output:
  html_document:
    df_print: paged
---

# Lecture des données
```{r}
amenorrhea = read.table("amenorrhea.dat",na.strings = ".")
names(amenorrhea) = c("ID","dose","temps","y")
head(amenorrhea)
```
# Imputation multiple

## Transformation au format large
```{r}
amenlarge = reshape(amenorrhea,timevar="temps",idvar=c("ID","dose"),direction="wide")
head(amenlarge)                    
```

## Imputation
```{r,results==FALSE}
library(mice)
amenlarge_imp=mice(data=amenlarge,m=25,seed=98,blocks=list("y.2","y.3","y.4"), formulas=list("y.2"=~y.1*dose,"y.3"=~y.1*dose+y.2*dose,"y.4"=~y.1*dose+y.2*dose+y.3*dose))
```

Fonction pour l'analyse. Il faut exécuter la transformation du format large des données imputées au format long pour l'analyse à l'intérieur de la fonction.
```{r}
library(tidyr)
estime.mod = function(fm,ID,dose,y.1,y.2,y.3,y.4)
{
  amenimp <- pivot_longer(data.frame(ID,dose,y.1,y.2,y.3,y.4),cols = starts_with("y"),
    names_to = c(".value","temps"),
    names_sep = "\\.",
    values_to = "y")
  # On décale le temps de -1 pour ramener le temps initial à 0 comme Fitzmaurice, Laird et Ware. 
  amenimp$temps = as.numeric(amenimp$temps)-1
  amenimp$temps2 = amenimp$temps^2
  geeglm(fm,data=amenimp,family=binomial,corstr="unstr",id=ID,scale.fix=T)
}
```

### Analyse des données après imputation multiple (sous l'hypothèse MAR)
```{r}
library(geepack)
amen_multimod = with(amenlarge_imp,estime.mod(y~dose*temps+dose*temps2,ID,dose,y.1,y.2,y.3,y.4))
```
```{r}
amen_combine = pool(amen_multimod)
amen_combine
```

# Pondération par la probabilité inverse de censure

# Ajout de variables pour l'observation précédente et la présence du sujet
On décale aussi le temps de -1 pour ramener le temps initial à 0 comme Fitzmaurice, Laird et Ware.
```{r}
amenorrhea$prevy = unlist(tapply(amenorrhea$y,amenorrhea$ID,function(vec) c(NA,vec[-length(vec)])))
amenorrhea$r = ifelse(is.na(amenorrhea$y),0,1)
amenorrhea$temps = amenorrhea$temps-1
head(amenorrhea)
```
On peut retirer les lignes des observations prévues après la perte au suivi
```{r}
amenorrhea = amenorrhea[amenorrhea$r==1 | !is.na(amenorrhea$prevy),]
head(amenorrhea)
```
# Modèle de la probabilité d'observer la réponse y
```{r}
probobs.mod = glm(r~factor(temps) + dose*prevy,data=amenorrhea,family=binomial)
pobs = predict(probobs.mod,type="response")
```
# Calcul des poids
On crée une variable de probabilité inverse de rétention dans l'étude
```{r}
amenorrhea$invp = NA
amenorrhea$invp[is.na(amenorrhea$prevy)] = 1
amenorrhea$invp[!is.na(amenorrhea$prevy)] = 1/pobs
head(amenorrhea)
```
On prend le produit des probabilités inverse chez chaque sujet pour obtenir les poids.
```{r}
amenorrhea$ipcw = unlist(tapply(amenorrhea$invp,amenorrhea$ID,cumprod))
head(amenorrhea)
tail(amenorrhea)
```
On normalise les poids. Pour ce faire il faut d'abord ordonner le jeu de donnée par temps d'observation.
```{r}
ord = order(amenorrhea$temps)
amenorrhea = amenorrhea[ord,]
nt = tapply(amenorrhea$y,amenorrhea$temps,function(vec) sum(!is.na(vec)))
amenorrhea$nt = nt[amenorrhea$temps+1]
amenorrhea$nipcw = unlist(tapply(amenorrhea$ipcw,amenorrhea$temps,function(vec) vec/sum(vec)))*amenorrhea$nt
head(amenorrhea)
tail(amenorrhea)
```
# Estimation du modèle en pondérant les observations
On commence par les poids bruts comme le font Fitzmaurice, Laird et Ware. 

La fonction *geeglm* donne les mêmes estimations que proc genmod de SAS. Il faut d'abord réordonner le jeu de donnée par identifiant pour utiliser cette fonction.
```{r}
library(geepack)
ord = order(amenorrhea$ID)
amenorrhea = amenorrhea[ord,]
amenorrhea$temps2 = amenorrhea$temps^2
amenorrhea.ipcw = geeglm(y~dose*temps+dose*temps2,data=amenorrhea,weights=ipcw,id=ID,family=binomial,scale.fix=T)
summary(amenorrhea.ipcw)
```
La fonction *geem* donne des estimations identiques.
```{r}
library(geeM)
amenorrhea.complet = amenorrhea[!is.na(amenorrhea$y),]
amenorrhea.ipcw = geem(y~dose*temps+dose*temps2,data=amenorrhea.complet,weights=ipcw,id=ID,family=binomial)
summary(amenorrhea.ipcw)
```
On essaie ensuite les poids normalisés. 

Ici aussi la fonction *geeglm* donne les mêmes estimations que proc genmod de SAS.
```{r}
amenorrhea.nipcw = geeglm(y~dose*temps+dose*temps2,data=amenorrhea,weights=nipcw,id=ID,family=binomial,scale.fix=T)
summary(amenorrhea.nipcw)
```
La fonction *geem* donne des estimations identiques.
```{r}
amenorrhea.nipcw = geem(y~dose*temps+dose*temps2,data=amenorrhea.complet,weights=nipcw,id=ID,family=binomial)
summary(amenorrhea.nipcw)
```